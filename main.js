/*
  INSIGHTS â€“ SUBCONSCIOUS AI
  Build file generated by esbuild
*/
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => InsightsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// types.ts
var DEFAULT_SETTINGS = {
  embeddingProvider: "tfidf-local",
  indexOnStartup: true,
  autoUpdateOnFileChange: true,
  recencyHalfLifeDays: 30,
  maxSearchResults: 20,
  ollama: {
    baseUrl: "http://localhost:11434",
    model: "nomic-embed-text"
  },
  rumination: {
    enabled: true,
    intervalMinutes: 30,
    minSimilarity: 0.25,
    useLinkGraphWeighting: true,
    writeDigest: false,
    digestNotePath: "INSIGHTS Digest.md",
    noveltyWeight: 0.4,
    focusTags: "",
    allowedStartHour: 8,
    allowedEndHour: 22,
    maxRepeatsPerPair: 3,
    bridgeSummary: true
  },
  ruminationState: {
    seenPairs: {}
  }
};

// settings.ts
var import_obsidian = require("obsidian");
var InsightsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "INSIGHTS \u2013 SUBCONSCIOUS AI" });
    new import_obsidian.Setting(containerEl).setName("Embedding provider").setDesc("Local TF-IDF doesn't use network. Ollama is local-only if installed.").addDropdown(
      (d) => d.addOption("tfidf-local", "TF-IDF (local)").addOption("ollama", "Ollama (dense)").addOption("openai", "OpenAI (reserved)").setValue(this.plugin.settings.embeddingProvider).onChange(async (v) => {
        this.plugin.settings.embeddingProvider = v;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Index on startup").addToggle((t) => t.setValue(this.plugin.settings.indexOnStartup).onChange(async (v) => {
      this.plugin.settings.indexOnStartup = v;
      await this.plugin.saveSettings();
    })).addExtraButton((b) => b.setIcon("refresh-ccw").setTooltip("Rebuild index").onClick(() => this.plugin.rebuildIndex()));
    new import_obsidian.Setting(containerEl).setName("Auto-update on file change").addToggle((t) => t.setValue(this.plugin.settings.autoUpdateOnFileChange).onChange(async (v) => {
      this.plugin.settings.autoUpdateOnFileChange = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Recency half-life (days)").addText((t) => t.setPlaceholder("30").setValue(String(this.plugin.settings.recencyHalfLifeDays)).onChange(async (v) => {
      const n = Number(v);
      if (!Number.isNaN(n) && n >= 0) {
        this.plugin.settings.recencyHalfLifeDays = n;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Max search results").addText((t) => t.setPlaceholder("20").setValue(String(this.plugin.settings.maxSearchResults)).onChange(async (v) => {
      const n = Number(v);
      if (!Number.isNaN(n) && n > 0) {
        this.plugin.settings.maxSearchResults = n;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "Ollama" });
    new import_obsidian.Setting(containerEl).setName("Base URL").addText((t) => t.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollama.baseUrl).onChange(async (v) => {
      this.plugin.settings.ollama.baseUrl = v || "http://localhost:11434";
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Model name").addText((t) => t.setPlaceholder("nomic-embed-text").setValue(this.plugin.settings.ollama.model).onChange(async (v) => {
      this.plugin.settings.ollama.model = v || "nomic-embed-text";
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Rumination" });
    new import_obsidian.Setting(containerEl).setName("Enable rumination").addToggle((t) => t.setValue(this.plugin.settings.rumination.enabled).onChange(async (v) => {
      this.plugin.settings.rumination.enabled = v;
      await this.plugin.saveSettings();
      this.plugin.refreshRuminator();
    }));
    new import_obsidian.Setting(containerEl).setName("Interval (minutes)").addText((t) => t.setPlaceholder("30").setValue(String(this.plugin.settings.rumination.intervalMinutes)).onChange(async (v) => {
      const n = Number(v);
      if (!Number.isNaN(n) && n > 0) {
        this.plugin.settings.rumination.intervalMinutes = n;
        await this.plugin.saveSettings();
        this.plugin.refreshRuminator();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Min cosine similarity").addText((t) => t.setPlaceholder("0.25").setValue(String(this.plugin.settings.rumination.minSimilarity)).onChange(async (v) => {
      const n = Number(v);
      if (!Number.isNaN(n) && n >= 0) {
        this.plugin.settings.rumination.minSimilarity = n;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Use link graph weighting").addToggle((t) => t.setValue(this.plugin.settings.rumination.useLinkGraphWeighting).onChange(async (v) => {
      this.plugin.settings.rumination.useLinkGraphWeighting = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Write digest note").addToggle((t) => t.setValue(this.plugin.settings.rumination.writeDigest).onChange(async (v) => {
      this.plugin.settings.rumination.writeDigest = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Digest note path").addText((t) => t.setPlaceholder("INSIGHTS Digest.md").setValue(this.plugin.settings.rumination.digestNotePath).onChange(async (v) => {
      this.plugin.settings.rumination.digestNotePath = v || "INSIGHTS Digest.md";
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Novelty weight (0\u20131)").addText((t) => t.setPlaceholder("0.4").setValue(String(this.plugin.settings.rumination.noveltyWeight)).onChange(async (v) => {
      const n = Number(v);
      if (!Number.isNaN(n) && n >= 0 && n <= 1) {
        this.plugin.settings.rumination.noveltyWeight = n;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Focus tags (comma-separated)").addText((t) => t.setPlaceholder("research, project-x").setValue(this.plugin.settings.rumination.focusTags).onChange(async (v) => {
      this.plugin.settings.rumination.focusTags = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Allowed start hour (0\u201323)").addText((t) => t.setPlaceholder("8").setValue(String(this.plugin.settings.rumination.allowedStartHour)).onChange(async (v) => {
      const n = Number(v);
      if (!Number.isNaN(n) && n >= 0 && n <= 23) {
        this.plugin.settings.rumination.allowedStartHour = n;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Allowed end hour (0\u201323)").addText((t) => t.setPlaceholder("22").setValue(String(this.plugin.settings.rumination.allowedEndHour)).onChange(async (v) => {
      const n = Number(v);
      if (!Number.isNaN(n) && n >= 0 && n <= 23) {
        this.plugin.settings.rumination.allowedEndHour = n;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Max repeats per pair").addText((t) => t.setPlaceholder("3").setValue(String(this.plugin.settings.rumination.maxRepeatsPerPair)).onChange(async (v) => {
      const n = Number(v);
      if (!Number.isNaN(n) && n >= 0) {
        this.plugin.settings.rumination.maxRepeatsPerPair = n;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Bridge summary sentence").addToggle((t) => t.setValue(this.plugin.settings.rumination.bridgeSummary).onChange(async (v) => {
      this.plugin.settings.rumination.bridgeSummary = v;
      await this.plugin.saveSettings();
    }));
  }
};

// view.ts
var import_obsidian2 = require("obsidian");
var INSIGHTS_VIEW_TYPE = "insights-view";
var InsightsView = class extends import_obsidian2.ItemView {
  constructor() {
    super(...arguments);
    __publicField(this, "containerElRef", null);
    __publicField(this, "onSearch", null);
    __publicField(this, "onRunRumination", null);
  }
  getViewType() {
    return INSIGHTS_VIEW_TYPE;
  }
  getDisplayText() {
    return "Insights";
  }
  getIcon() {
    return "brain-circuit";
  }
  setHandlers(params) {
    this.onSearch = params.onSearch;
    this.onRunRumination = params.onRunRumination;
  }
  async onOpen() {
    const container = this.contentEl;
    container.empty();
    container.addClass("insights-view");
    const searchBar = container.createDiv({ cls: "insights-searchbar" });
    const input = searchBar.createEl("input", { type: "text", placeholder: "Semantic search\u2026", cls: "insights-input" });
    const button = searchBar.createEl("button", { text: "Search" });
    const resultsEl = container.createDiv({ cls: "insights-results" });
    const rumEl = container.createDiv({ cls: "insights-ruminations" });
    rumEl.createEl("h3", { text: "Ruminations" });
    const rumBtn = rumEl.createEl("button", { text: "Refresh ruminations" });
    const rumList = rumEl.createDiv();
    const renderResults = (results) => {
      resultsEl.empty();
      for (const r of results) {
        const item = resultsEl.createDiv({ cls: "insights-result" });
        item.createEl("div", { text: r.title, cls: "insights-title" });
        item.createEl("div", { text: r.excerpt });
        item.createEl("div", { cls: "insights-meta", text: `sim ${r.similarity.toFixed(3)} \xB7 rec ${r.recencyBoost.toFixed(3)} \xB7 sent ${r.sentimentBoost.toFixed(3)} \xB7 score ${r.score.toFixed(3)}` });
        item.onclick = () => {
          const file = this.app.vault.getAbstractFileByPath(r.path);
          if (file instanceof import_obsidian2.TFile) this.app.workspace.getLeaf(true).openFile(file);
        };
      }
    };
    const renderRuminations = (items) => {
      rumList.empty();
      for (const s of items) {
        const item = rumList.createDiv({ cls: "insights-result" });
        item.createEl("div", { text: `${s.aTitle} \u21C4 ${s.bTitle}` });
        item.createEl("div", { cls: "insights-meta", text: `score ${s.score.toFixed(3)} \xB7 sim ${s.similarity.toFixed(3)} \xB7 link ${s.linkAffinity.toFixed(3)} \xB7 novelty ${s.noveltyBoost.toFixed(3)}` });
        if (s.bridge) item.createEl("div", { text: s.bridge });
      }
    };
    button.onclick = async () => {
      if (!this.onSearch) return;
      const q = input.value.trim();
      const res = await this.onSearch(q);
      renderResults(res);
    };
    rumBtn.onclick = async () => {
      if (!this.onRunRumination) return;
      const res = await this.onRunRumination();
      renderRuminations(res);
    };
  }
  async onClose() {
    this.contentEl.empty();
  }
};

// indexer.ts
var import_obsidian3 = require("obsidian");

// tokenize.ts
var STOP_WORDS = /* @__PURE__ */ new Set([
  "a",
  "an",
  "and",
  "are",
  "as",
  "at",
  "be",
  "but",
  "by",
  "for",
  "if",
  "in",
  "into",
  "is",
  "it",
  "no",
  "not",
  "of",
  "on",
  "or",
  "such",
  "that",
  "the",
  "their",
  "then",
  "there",
  "these",
  "they",
  "this",
  "to",
  "was",
  "will",
  "with",
  "from",
  "we",
  "you",
  "your",
  "i",
  "our",
  "ours",
  "yours",
  "me",
  "my",
  "mine",
  "he",
  "she",
  "his",
  "her",
  "hers",
  "them",
  "those",
  "were",
  "been",
  "being",
  "about",
  "over",
  "under",
  "again",
  "further",
  "do",
  "does",
  "did",
  "doing",
  "so",
  "than",
  "too",
  "very",
  "can",
  "could",
  "should",
  "would",
  "may",
  "might"
]);
function stripMarkdown(input) {
  let text = input;
  text = text.replace(/```[\s\S]*?```/g, " ");
  text = text.replace(/`[^`]*`/g, " ");
  text = text.replace(/!\[[^\]]*\]\([^)]*\)/g, " ");
  text = text.replace(/\[([^\]]+)\]\([^)]*\)/g, "$1");
  text = text.replace(/^[#>\-+*]+\s+/gm, "");
  text = text.replace(/<[^>]+>/g, " ");
  text = text.replace(/^---[\s\S]*?---/m, " ");
  text = text.replace(/[\t\r]+/g, " ");
  return text;
}
function lemmatizeToken(token) {
  if (token.endsWith("ies") && token.length > 4) {
    return token.slice(0, -3) + "y";
  }
  if (token.endsWith("sses")) {
    return token.slice(0, -2);
  }
  if (token.endsWith("s") && !token.endsWith("ss") && token.length > 3) {
    return token.slice(0, -1);
  }
  if (token.endsWith("ing") && token.length > 5) {
    return token.slice(0, -3);
  }
  if (token.endsWith("ed") && token.length > 4) {
    return token.slice(0, -2);
  }
  return token;
}
function tokenize(text) {
  const stripped = stripMarkdown(text.toLowerCase());
  const rough = stripped.split(/[^a-z0-9]+/g);
  const tokens = [];
  for (const raw of rough) {
    if (!raw) continue;
    if (STOP_WORDS.has(raw)) continue;
    const lemma = lemmatizeToken(raw);
    if (lemma && !STOP_WORDS.has(lemma)) tokens.push(lemma);
  }
  return tokens;
}

// embeddings.ts
var OllamaClient = class {
  constructor(opts) {
    __publicField(this, "baseUrl");
    __publicField(this, "model");
    this.baseUrl = opts.baseUrl.replace(/\/?$/, "");
    this.model = opts.model;
  }
  async embed(texts) {
    const embeddings = [];
    for (const text of texts) {
      try {
        const res = await fetch(`${this.baseUrl}/api/embeddings`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ model: this.model, prompt: text })
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (Array.isArray(data?.data)) {
          const vec = data.data[0]?.embedding;
          if (!vec) throw new Error("Missing embedding");
          embeddings.push(vec);
        } else if (Array.isArray(data?.embedding)) {
          embeddings.push(data.embedding);
        } else if (Array.isArray(data?.embeddings)) {
          embeddings.push(data.embeddings[0]);
        } else {
          throw new Error("Unrecognized embeddings response");
        }
      } catch (e) {
        throw e;
      }
    }
    return embeddings;
  }
};

// indexer.ts
var SENTIMENT_LEXICON = {
  good: 1,
  great: 1,
  excellent: 1,
  happy: 1,
  love: 1,
  positive: 1,
  success: 1,
  win: 1,
  bad: -1,
  poor: -1,
  terrible: -1,
  sad: -1,
  hate: -1,
  negative: -1,
  fail: -1,
  loss: -1
};
function simpleSentiment(tokens) {
  let score = 0;
  for (const t of tokens) {
    if (t in SENTIMENT_LEXICON) score += SENTIMENT_LEXICON[t];
  }
  if (score > 0) return Math.min(1, score / 5);
  if (score < 0) return Math.max(-1, score / 5);
  return 0;
}
function computeWordCount(tokens) {
  return tokens.length;
}
function vectorDot(a, b) {
  let sum = 0;
  const [shorter, longer] = Object.keys(a).length < Object.keys(b).length ? [a, b] : [b, a];
  for (const k in shorter) {
    const av = shorter[k];
    const bv = longer[k];
    if (bv !== void 0) sum += av * bv;
  }
  return sum;
}
function vectorNorm(a) {
  let sum = 0;
  for (const k in a) sum += a[k] * a[k];
  return Math.sqrt(sum);
}
function cosineSparse(a, b) {
  const denom = vectorNorm(a) * vectorNorm(b);
  if (denom === 0) return 0;
  return vectorDot(a, b) / denom;
}
function cosineDense(a, b) {
  let dot = 0, an = 0, bn = 0;
  const n = Math.min(a.length, b.length);
  for (let i = 0; i < n; i++) {
    dot += a[i] * b[i];
    an += a[i] * a[i];
    bn += b[i] * b[i];
  }
  const denom = Math.sqrt(an) * Math.sqrt(bn);
  if (denom === 0) return 0;
  return dot / denom;
}
function recencyWeight(mtimeMs, halfLifeDays, nowMs) {
  if (halfLifeDays <= 0) return 1;
  const msPerDay = 24 * 60 * 60 * 1e3;
  const ageDays = Math.max(0, (nowMs - mtimeMs) / msPerDay);
  return Math.pow(0.5, ageDays / halfLifeDays);
}
function buildExcerpt(content, queryTokens) {
  const lines = content.split(/\n+/);
  for (const line of lines) {
    const lower = line.toLowerCase();
    for (const t of queryTokens) {
      if (t && lower.includes(t)) return line.trim().slice(0, 240);
    }
  }
  return (lines[0] || "").trim().slice(0, 240);
}
function readHead(content, maxChars = 1200) {
  const lines = content.split(/\n+/);
  const head = lines.slice(0, 40).join("\n");
  return head.slice(0, maxChars);
}
function firstH1OrBasename(file, content) {
  const m = content.match(/^#\s+(.+)$/m);
  if (m) return m[1].trim();
  return file.basename;
}
function getTagsFromCache(app, file) {
  const cache = app.metadataCache.getFileCache(file);
  const tags = /* @__PURE__ */ new Set();
  if (cache?.tags) {
    for (const t of cache.tags) if (t.tag) tags.add(t.tag.replace(/^#/, ""));
  }
  if (cache?.frontmatter) {
    const fm = cache.frontmatter;
    const fmTags = fm["tags"];
    if (Array.isArray(fmTags)) fmTags.forEach((x) => typeof x === "string" && tags.add(x.replace(/^#/, "")));
    else if (typeof fmTags === "string") fmTags.split(",").forEach((x) => tags.add(x.trim().replace(/^#/, "")));
  }
  return Array.from(tags);
}
async function indexAllMarkdown(app, settings) {
  const files = app.vault.getMarkdownFiles();
  const documents = {};
  const termDocFreq = {};
  const docTermCounts = {};
  const docVectors = {};
  const invertedIndex = {};
  for (const file of files) {
    const content = await app.vault.cachedRead(file);
    const tokens = tokenize(content);
    const counts = {};
    for (const t of tokens) counts[t] = (counts[t] || 0) + 1;
    docTermCounts[file.path] = counts;
    for (const t in counts) termDocFreq[t] = (termDocFreq[t] || 0) + 1;
    const meta = {
      path: file.path,
      title: firstH1OrBasename(file, content),
      mtimeMs: file.stat.mtime,
      wordCount: computeWordCount(tokens),
      sentiment: simpleSentiment(tokens),
      tags: getTagsFromCache(app, file)
    };
    documents[file.path] = meta;
  }
  const N = files.length || 1;
  const vocabularyIdf = {};
  for (const term in termDocFreq) {
    const df = termDocFreq[term];
    vocabularyIdf[term] = Math.log(N / (1 + df));
  }
  for (const path in docTermCounts) {
    const counts = docTermCounts[path];
    const vec = {};
    let maxTf = 1;
    for (const t in counts) if (counts[t] > maxTf) maxTf = counts[t];
    for (const t in counts) {
      const tf = 0.5 + 0.5 * (counts[t] / maxTf);
      const idf = vocabularyIdf[t] || 0;
      vec[t] = tf * idf;
      (invertedIndex[t] || (invertedIndex[t] = [])).push(path);
    }
    docVectors[path] = vec;
  }
  let denseVectors;
  if (settings.embeddingProvider === "ollama") {
    try {
      const client = new OllamaClient({ baseUrl: settings.ollama.baseUrl, model: settings.ollama.model });
      denseVectors = {};
      for (const file of files) {
        const content = await app.vault.cachedRead(file);
        const head = `${documents[file.path].title}

${readHead(content)}`;
        const [vec] = await client.embed([head]);
        if (Array.isArray(vec)) denseVectors[file.path] = vec;
      }
    } catch (e) {
      new import_obsidian3.Notice("Ollama embeddings failed. Falling back to TF-IDF.");
      denseVectors = void 0;
    }
  }
  return { documents, vocabularyIdf, docVectors, invertedIndex, denseVectors };
}
async function search(app, settings, index, query) {
  if (!index) return [];
  const { documents, vocabularyIdf, docVectors, denseVectors } = index;
  const nowMs = Date.now();
  const contentTokens = tokenize(query);
  if (contentTokens.length === 0) return [];
  const qCounts = {};
  for (const t of contentTokens) qCounts[t] = (qCounts[t] || 0) + 1;
  let qVec = {};
  let maxTf = 1;
  for (const t in qCounts) if (qCounts[t] > maxTf) maxTf = qCounts[t];
  for (const t in qCounts) {
    const tf = 0.5 + 0.5 * (qCounts[t] / maxTf);
    const idf = vocabularyIdf[t] || 0;
    qVec[t] = tf * idf;
  }
  const results = [];
  if (settings.embeddingProvider === "ollama" && denseVectors) {
    try {
      const client = new OllamaClient({ baseUrl: settings.ollama.baseUrl, model: settings.ollama.model });
      const [qDense] = await client.embed([query]);
      for (const path in documents) {
        const dDense = denseVectors[path];
        if (!dDense) continue;
        const sim = cosineDense(qDense, dDense);
        const rec = recencyWeight(documents[path].mtimeMs, settings.recencyHalfLifeDays, nowMs);
        const sent = 1 + 0.1 * (documents[path].sentiment || 0);
        const score = Math.max(0, sim) * rec * sent;
        results.push({
          path,
          title: documents[path].title,
          excerpt: documents[path].title,
          similarity: sim,
          recencyBoost: rec,
          sentimentBoost: sent,
          score
        });
      }
    } catch (e) {
    }
  }
  if (results.length === 0) {
    for (const path in documents) {
      const sim = cosineSparse(qVec, docVectors[path] || {});
      if (sim <= 0) continue;
      const rec = recencyWeight(documents[path].mtimeMs, settings.recencyHalfLifeDays, nowMs);
      const sent = 1 + 0.1 * (documents[path].sentiment || 0);
      results.push({
        path,
        title: documents[path].title,
        excerpt: documents[path].title,
        similarity: sim,
        recencyBoost: rec,
        sentimentBoost: sent,
        score: sim * rec * sent
      });
    }
  }
  const topK = results.sort((a, b) => b.score - a.score).slice(0, settings.maxSearchResults);
  for (const r of topK) {
    try {
      const file = app.vault.getAbstractFileByPath(r.path);
      if (file instanceof import_obsidian3.TFile) {
        const content = await app.vault.cachedRead(file);
        r.excerpt = buildExcerpt(content, contentTokens);
      }
    } catch {
    }
  }
  return topK;
}

// ruminator.ts
var import_obsidian4 = require("obsidian");
function withinAllowedHours(start, end, now = /* @__PURE__ */ new Date()) {
  const h = now.getHours();
  if (start === end) return true;
  if (start < end) return h >= start && h < end;
  return h >= start || h < end;
}
function pairKey(a, b) {
  return a < b ? `${a}|${b}` : `${b}|${a}`;
}
function jaccard(a, b) {
  if (a.size === 0 && b.size === 0) return 0;
  let inter = 0;
  for (const v of a) if (b.has(v)) inter++;
  const union = a.size + b.size - inter;
  return union === 0 ? 0 : inter / union;
}
function topSharedTokens(a, b, k = 5) {
  const shared = [];
  for (const t in a) if (b[t] !== void 0) shared.push([t, a[t] + b[t]]);
  shared.sort((x, y) => y[1] - x[1]);
  return shared.slice(0, k).map(([t]) => t);
}
var Ruminator = class {
  constructor(app, getIndex, settings, persist) {
    __publicField(this, "app");
    __publicField(this, "getIndex");
    __publicField(this, "settings");
    __publicField(this, "persist");
    __publicField(this, "timer", null);
    this.app = app;
    this.getIndex = getIndex;
    this.settings = settings;
    this.persist = persist;
  }
  updateSettings(settings) {
    this.settings = settings;
    this.stop();
    if (this.settings.rumination.enabled) this.start();
  }
  start() {
    this.stop();
    if (!this.settings.rumination.enabled) return;
    const intervalMs = Math.max(1, this.settings.rumination.intervalMinutes) * 6e4;
    this.timer = window.setInterval(() => this.tick().catch(() => {
    }), intervalMs);
  }
  stop() {
    if (this.timer !== null) {
      window.clearInterval(this.timer);
      this.timer = null;
    }
  }
  async tick(force = false) {
    if (!force && !withinAllowedHours(this.settings.rumination.allowedStartHour, this.settings.rumination.allowedEndHour)) {
      return [];
    }
    const index = this.getIndex();
    if (!index) return [];
    const suggestions = this.computeSuggestions(index);
    if (this.settings.rumination.writeDigest && suggestions.length > 0) {
      await this.writeDigestNote(suggestions);
    }
    return suggestions;
  }
  computeSuggestions(index) {
    const minSim = this.settings.rumination.minSimilarity;
    const useLinkGraph = this.settings.rumination.useLinkGraphWeighting;
    const focusTags = new Set(
      this.settings.rumination.focusTags.split(",").map((s) => s.trim().toLowerCase()).filter(Boolean)
    );
    const docs = Object.keys(index.documents);
    const docVectors = index.docVectors;
    const neighbors = this.buildNeighborSets();
    const now = Date.now();
    const items = [];
    for (let i = 0; i < docs.length; i++) {
      for (let j = i + 1; j < docs.length; j++) {
        const a = docs[i];
        const b = docs[j];
        const sim = cosineSparse(docVectors[a] || {}, docVectors[b] || {});
        if (sim < minSim) continue;
        if (focusTags.size > 0) {
          const aTags = new Set(index.documents[a].tags.map((t) => t.toLowerCase()));
          const bTags = new Set(index.documents[b].tags.map((t) => t.toLowerCase()));
          const hasFocus = [...focusTags].some((t) => aTags.has(t) || bTags.has(t));
          if (!hasFocus) continue;
        }
        const linkAff = useLinkGraph ? jaccard(neighbors[a] || /* @__PURE__ */ new Set(), neighbors[b] || /* @__PURE__ */ new Set()) : 0;
        const noveltyEntry = this.settings.ruminationState.seenPairs[pairKey(a, b)];
        const repeats = noveltyEntry?.count ?? 0;
        if (repeats >= this.settings.rumination.maxRepeatsPerPair) continue;
        const noveltyBoost = this.settings.rumination.noveltyWeight * (1 / (1 + repeats));
        const score = sim * (1 + linkAff) * (1 + noveltyBoost);
        const sharedTokens = topSharedTokens(docVectors[a] || {}, docVectors[b] || {}, 5);
        let bridge;
        if (this.settings.rumination.bridgeSummary && sharedTokens.length) {
          bridge = `${index.documents[a].title} and ${index.documents[b].title} connect via ${sharedTokens.slice(0, 3).join(", ")}.`;
        }
        items.push({
          aPath: a,
          bPath: b,
          aTitle: index.documents[a].title,
          bTitle: index.documents[b].title,
          score,
          similarity: sim,
          linkAffinity: linkAff,
          noveltyBoost,
          sharedTokens,
          bridge
        });
      }
    }
    items.sort((x, y) => y.score - x.score);
    const top = items.slice(0, 10);
    for (const s of top) {
      const key = pairKey(s.aPath, s.bPath);
      const entry = this.settings.ruminationState.seenPairs[key] || { count: 0, lastShownMs: 0 };
      entry.count += 1;
      entry.lastShownMs = now;
      this.settings.ruminationState.seenPairs[key] = entry;
    }
    void this.persist();
    return top;
  }
  buildNeighborSets() {
    const resolved = this.app.metadataCache.resolvedLinks;
    const neighbors = {};
    for (const from in resolved) {
      const targets = Object.keys(resolved[from] || {});
      neighbors[from] || (neighbors[from] = /* @__PURE__ */ new Set());
      for (const t of targets) neighbors[from].add(t);
    }
    return neighbors;
  }
  async writeDigestNote(suggestions) {
    const path = this.settings.rumination.digestNotePath || "INSIGHTS Digest.md";
    let file = this.app.vault.getAbstractFileByPath(path);
    if (!(file instanceof import_obsidian4.TFile)) {
      file = await this.app.vault.create(path, `# INSIGHTS Digest
`);
    }
    if (!(file instanceof import_obsidian4.TFile)) return;
    const lines = [];
    const now = /* @__PURE__ */ new Date();
    lines.push(`
## ${now.toLocaleString()}
`);
    for (const s of suggestions) {
      lines.push(`- ${s.aTitle} \u21C4 ${s.bTitle} (score: ${s.score.toFixed(3)}, sim: ${s.similarity.toFixed(3)}, link: ${s.linkAffinity.toFixed(3)})`);
      if (s.bridge) lines.push(`  - ${s.bridge}`);
    }
    await this.app.vault.append(file, lines.join("\n"));
    new import_obsidian4.Notice("INSIGHTS digest updated");
  }
};

// main.ts
var RIBBON_SVG = `<svg viewBox="0 0 24 24" width="24" height="24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2a8 8 0 0 0-8 8v1a6 6 0 0 0 6 6h.5V22l3.5-3h.5a6 6 0 0 0 6-6V10a8 8 0 0 0-8-8Z" fill="currentColor"/></svg>`;
var InsightsPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings", structuredClone(DEFAULT_SETTINGS));
    __publicField(this, "index", null);
    __publicField(this, "ruminator", null);
  }
  async onload() {
    (0, import_obsidian5.addIcon)("insights-logo", RIBBON_SVG);
    await this.loadSettings();
    this.registerView(INSIGHTS_VIEW_TYPE, (leaf) => new InsightsView(leaf));
    this.addRibbonIcon("insights-logo", "Open Insights", async () => this.openInsightsView());
    this.addCommand({ id: "open-insights-view", name: "Open Insights view", callback: () => this.openInsightsView() });
    this.addCommand({ id: "rebuild-index", name: "Rebuild index", callback: () => this.rebuildIndex() });
    this.addCommand({ id: "run-rumination-now", name: "Run rumination now", callback: async () => {
      if (!this.ruminator) return;
      const suggestions = await this.ruminator.tick(true);
      new import_obsidian5.Notice(`Ruminations: ${suggestions.length} suggestions`);
    } });
    this.addSettingTab(new InsightsSettingTab(this.app, this));
    this.registerEvent(this.app.vault.on("modify", (f) => this.onFileChange(f)));
    this.registerEvent(this.app.vault.on("create", (f) => this.onFileChange(f)));
    this.registerEvent(this.app.vault.on("delete", (f) => this.onFileChange(f)));
    if (this.settings.indexOnStartup) {
      void this.rebuildIndex();
    }
    this.refreshRuminator();
  }
  async onunload() {
    if (this.ruminator) this.ruminator.stop();
  }
  async loadSettings() {
    const data = await this.loadData();
    this.settings = Object.assign(structuredClone(DEFAULT_SETTINGS), data || {});
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async openInsightsView() {
    const leaf = this.getLeaf(true);
    await leaf.setViewState({ type: INSIGHTS_VIEW_TYPE, active: true });
    const view = leaf.view;
    view.setHandlers({
      onSearch: async (q) => search(this.app, this.settings, this.index, q),
      onRunRumination: async () => this.ruminator ? this.ruminator.tick(true) : []
    });
  }
  getLeaf(split) {
    if (this.app.workspace.getLeavesOfType(INSIGHTS_VIEW_TYPE).length > 0) {
      return this.app.workspace.getLeavesOfType(INSIGHTS_VIEW_TYPE)[0];
    }
    return this.app.workspace.getLeaf(split);
  }
  async rebuildIndex() {
    new import_obsidian5.Notice("INSIGHTS: indexing\u2026");
    try {
      this.index = await indexAllMarkdown(this.app, this.settings);
      new import_obsidian5.Notice("INSIGHTS: index ready");
    } catch (e) {
      console.error(e);
      new import_obsidian5.Notice("INSIGHTS: index failed");
    }
  }
  async onFileChange(f) {
    if (!this.settings.autoUpdateOnFileChange) return;
    if (!(f instanceof import_obsidian5.TFile) || f.extension !== "md") return;
    window.setTimeout(() => this.rebuildIndex(), 300);
  }
  refreshRuminator() {
    if (this.ruminator) this.ruminator.stop();
    this.ruminator = new Ruminator(this.app, () => this.index, this.settings, () => this.saveSettings());
    if (this.settings.rumination.enabled) this.ruminator.start();
  }
};
